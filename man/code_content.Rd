% Generated by roxygen2: do not edit by hand
% Please edit documentation in R/your_script_name.R
\name{code_content}
\alias{code_content}
\title{Code Text Content Using Chat AI API and a Codebook}
\usage{
code_content(
  x,
  general_instructions,
  formatting_instructions,
  codebook,
  model = "meta-llama-3.1-8b-instruct",
  temperature = 0,
  sleep = 1,
  drop_json = TRUE,
  drop_instructions = TRUE,
  keep_all_original_rows = TRUE
)
}
\arguments{
\item{x}{data.frame. Input data containing at least a 'text' column with the
texts to be coded.}

\item{general_instructions}{character. General instructions for the coding task
provided to the language model.}

\item{formatting_instructions}{character. Specific instructions for the model
on how to format its JSON output.}

\item{codebook}{character. A JSON string representing the codebook, typically
generated by \code{\link{parse_codebook}}.}

\item{model}{character. The identifier of the Chat AI model to use.}

\item{temperature}{numeric. The sampling temperature for the API call.}

\item{sleep}{numeric. Seconds to pause between API calls to avoid rate limits.}

\item{drop_json}{logical. If TRUE, removes the raw JSON response column from
the final output.}

\item{drop_instructions}{logical. If TRUE, removes the 'instructions' column
(if present in the parsed results) from the final output.}

\item{keep_all_original_rows}{logical. If TRUE (default), the output includes
all rows from the original input data frame \code{x}, with NA values in coded
columns for rows that failed processing. If FALSE, only rows that were
successfully coded and parsed are returned.}
}
\value{
A data.frame combining the original data (or a subset based on
\code{keep_all_original_rows}) with the parsed coding results from the API.
Each coded category typically results in a separate row if multiple
categories are defined in the codebook.
}
\description{
Iterates through rows of a data frame containing text, sends each text along
with instructions and a codebook to the Chat AI API for classification/coding,
parses the JSON responses, and joins the results back to the original data.
}
\details{
This function relies on \code{\link{chatai}} for API calls and thus requires
the \code{chatai_key} environment variable to be set. The structure of the
expected JSON response from the API should align with the
\code{formatting_instructions} provided and the parsing logic within this
function.
}
\examples{
\dontrun{
# Requires API key set in environment variable 'chatai_key'
# Assume 'my_texts.csv' has a 'text' column
# Assume 'my_codebook.csv' defines categories/labels

texts_to_code <- readr::read_csv("my_texts.csv")
gen_instr <- "Classify the sentiment of the following text."
fmt_instr <- "Return JSON like: {\\"sentiment\\": {\\"label\\": \\"chosen_label\\"}}"
codebook_json <- parse_codebook("my_codebook.csv")

coded_results <- code_content(
  x = texts_to_code,
  general_instructions = gen_instr,
  formatting_instructions = fmt_instr,
  codebook = codebook_json,
  model = "meta-llama-3.1-8b-instruct",
  sleep = 2
 )

print(head(coded_results))
}
}
